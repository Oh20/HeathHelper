name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: oh20
  KUBERNETES_NAMESPACE: default
  DEPLOYMENT_TIMEOUT: 300s

jobs:
  validate:
    runs-on: [self-hosted, windows]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Validate directory structure
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $SERVICES = @(
            "AppoitmentScheduler",
            "HealthHelperAuthSystem",
            "MedicosService",
            "SchedulerConsumer",
            "UserRegisterConsumer"
          )
          
          foreach ($SERVICE in $SERVICES) {
            Write-Host "Validating $SERVICE..."
            
            if (-not (Test-Path "./$SERVICE")) {
              Write-Error "Directory ./$SERVICE not found"
              exit 1
            }
            
            if (-not (Test-Path "./$SERVICE/Dockerfile")) {
              Write-Error "Dockerfile not found in ./$SERVICE"
              exit 1
            }
          }
          
          Write-Host "All services validated successfully"

  build:
    needs: validate
    runs-on: [self-hosted, windows]
    strategy:
      matrix:
        service: [
          'appoitmentscheduler',
          'healthhelperauthsystem',
          'medicosservice',
          'schedulerconsumer',
          'userregisterconsumer'
        ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Get version
        id: get_version
        shell: pwsh
        run: |
          $version = git rev-parse --short HEAD
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT

      - name: Build and push
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $SERVICE = "${{ matrix.service }}"
          $VERSION = "${{ steps.get_version.outputs.VERSION }}"
          $IMAGE_NAME = "${{ env.REGISTRY }}/$SERVICE"
          
          Write-Host "Building $SERVICE..."
          
          docker build -t ${IMAGE_NAME}:${VERSION} ./$SERVICE
          if (-not $?) {
            Write-Error "Docker build failed for $SERVICE"
            exit 1
          }
          
          docker tag ${IMAGE_NAME}:${VERSION} ${IMAGE_NAME}:latest
          
          Write-Host "Pushing $SERVICE images..."
          docker push ${IMAGE_NAME}:${VERSION}
          docker push ${IMAGE_NAME}:latest

  deploy:
    needs: build
    runs-on: [self-hosted, windows]
    env:
      NAMESPACE: default
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Get version
        id: get_version
        shell: pwsh
        run: |
          $version = git rev-parse --short HEAD
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT

      - name: Verify Kubernetes Context
        shell: pwsh
        run: |
          try {
            Write-Host "Attempting to use minikube context..."
            kubectl config use-context minikube
            if (-not $?) {
              Write-Host "Minikube context failed, trying docker-desktop..."
              kubectl config use-context docker-desktop
            }
            
            kubectl get nodes
            if (-not $?) {
              throw "Failed to connect to Kubernetes cluster"
            }
            
            $context = kubectl config current-context
            Write-Host "Successfully connected to Kubernetes context: $context"
          }
          catch {
            Write-Error "Kubernetes context verification failed: $_"
            exit 1
          }

      - name: Apply Kubernetes Configurations
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          $VERSION = "${{ steps.get_version.outputs.VERSION }}"
          $NAMESPACE = "default"
          
          # Função para logar com segurança
          function Safe-Log {
            param([string]$Message)
            if ($Message) { Write-Host $Message }
          }
          
          # Definir serviços com seus nomes de deployment corretos
          $SERVICES = @(
            @{
              Name="HelHelperUser-Consumer"; 
              DeploymentName="user-register-consumer";
              DeploymentFiles=@("user-register-consumer-deployment.yaml");
              Dir="HelHelperUser"
            },
            @{
              Name="HelHelperUser-Producer"; 
              DeploymentName="user-register-producer";
              DeploymentFiles=@("user-register-producer-deployment.yaml");
              Dir="HelHelperUser"
            },
            @{
              Name="HelthHelperAuth"; 
              DeploymentName="auth-service";
              DeploymentFiles=@("auth-service-deployment.yaml");
              Dir="HelthHelperAuth"
            },
            @{
              Name="HelthHelperConsumer"; 
              DeploymentName="helth-helper-consumer";
              DeploymentFiles=@("HelthHelperConsumer.yaml");
              Dir="HelthHelperConsumer"
            },
            @{
              Name="HelthHelperProducer"; 
              DeploymentName="helth-helper-producer";
              DeploymentFiles=@("HelthHelperProducer.yaml");
              Dir="HelthHelperProducer"
            }
          )
          
          # Aplicar configurações base
          @("k8s/RabbitMQ", "k8s/config") | ForEach-Object {
            if (Test-Path $_) {
              Safe-Log "Applying configurations from $_..."
              kubectl apply -f $_
            }
          }
          
          # Processar cada serviço
          foreach ($SERVICE in $SERVICES) {
            $serviceName = $SERVICE.Name
            $deploymentName = $SERVICE.DeploymentName
            $serviceDir = $SERVICE.Dir
            
            Safe-Log "Deploying $serviceName..."
            
            try {
              $k8sPath = "k8s/$serviceDir"
              if (-not (Test-Path $k8sPath)) {
                Safe-Log "K8s directory not found for $serviceName at $k8sPath"
                continue
              }
              
              # Processar arquivos YAML específicos do serviço
              foreach ($deploymentFile in $SERVICE.DeploymentFiles) {
                $fullPath = Join-Path $k8sPath $deploymentFile
                
                if (-not (Test-Path $fullPath)) {
                  Safe-Log "Deployment file $deploymentFile not found for $serviceName"
                  continue
                }
                
                # Ler e atualizar conteúdo do arquivo
                $content = Get-Content $fullPath -Raw
                $updatedContent = $content -replace '(:latest|:v\d+\.\d+\.\d+|:[a-f0-9]+)', ":$VERSION"
                $updatedContent | Set-Content $fullPath
                
                Safe-Log ("Applying " + $deploymentFile)
                kubectl apply -f $fullPath
                
                if (-not $?) {
                  throw "Failed to apply $deploymentFile"
                }
              }
              
              # Verificar deployment diretamente
              Safe-Log "Waiting for $deploymentName deployment rollout..."
              
              $timeout = 300
              $startTime = Get-Date
              
              while ($true) {
                $deployment = kubectl get deployment "$deploymentName" `
                  -n "$NAMESPACE" `
                  -o jsonpath='{.status.conditions[?(@.type=="Available")].status}'
                
                $readyReplicas = kubectl get deployment "$deploymentName" `
                  -n "$NAMESPACE" `
                  -o jsonpath='{.status.readyReplicas}'
                
                if ($deployment -eq "True" -and $readyReplicas -gt 0) {
                  Safe-Log "Deployment $deploymentName is ready with $readyReplicas replicas"
                  break
                }
                
                # Verificar timeout
                $elapsedTime = (Get-Date) - $startTime
                if ($elapsedTime.TotalSeconds -gt $timeout) {
                  throw "Deployment $deploymentName timed out after $timeout seconds"
                }
                
                # Pequeno delay para evitar sobrecarga
                Start-Sleep -Seconds 5
              }
              
              Safe-Log "$serviceName deployment successful"
            }
            catch {
              Safe-Log "Deployment error for $serviceName`: $($_.Exception.Message)"
              
              # Logs de diagnóstico
              Safe-Log "Deployment status:"
              kubectl get deployments -n "$NAMESPACE"
              
              Safe-Log "Pods status:"
              kubectl get pods -n "$NAMESPACE"
              
              # Detalhes específicos do deployment com problema
              Safe-Log "Detailed deployment status for $deploymentName:"
              kubectl describe deployment "$deploymentName" -n "$NAMESPACE"
              
              exit 1
            }
          }

      - name: Verify Deployments
        if: success()
        shell: pwsh
        run: |
          $SERVICES = @(
            "user-register-consumer",
            "user-register-producer",
            "auth-service",
            "helth-helper-consumer",
            "helth-helper-producer"
          )
          $NAMESPACE = "default"

          foreach ($DEPLOYMENT in $SERVICES) {
            Safe-Log "Verifying $DEPLOYMENT..."
            
            $readyReplicas = kubectl get deployment "$DEPLOYMENT" `
              -n "$NAMESPACE" `
              -o jsonpath='{.status.readyReplicas}'
            
            $availableReplicas = kubectl get deployment "$DEPLOYMENT" `
              -n "$NAMESPACE" `
              -o jsonpath='{.status.availableReplicas}'
            
            if ($readyReplicas -lt 1 -or $availableReplicas -lt 1) {
              Write-Error "Deployment $DEPLOYMENT does not have any ready or available replicas"
              
              # Logs de diagnóstico adicionais
              Safe-Log "Deployment details:"
              kubectl describe deployment "$DEPLOYMENT" -n "$NAMESPACE"
              
              Safe-Log "Pod status:"
              kubectl get pods -l app="$DEPLOYMENT" -n "$NAMESPACE"
              
              exit 1
            }
            
            Safe-Log "$DEPLOYMENT verification completed successfully"
          }