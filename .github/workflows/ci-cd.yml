name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: oh20
  KUBERNETES_NAMESPACE: default
  DEPLOYMENT_TIMEOUT: 300s

jobs:
  validate:
    runs-on: [self-hosted, windows]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Validate directory structure
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $SERVICES = @(
            "AppoitmentScheduler",
            "HealthHelperAuthSystem",
            "MedicosService",
            "SchedulerConsumer",
            "UserRegisterConsumer"
          )
          
          foreach ($SERVICE in $SERVICES) {
            Write-Host "Validating $SERVICE..."
            
            if (-not (Test-Path "./$SERVICE")) {
              Write-Error "Directory ./$SERVICE not found"
              exit 1
            }
            
            if (-not (Test-Path "./$SERVICE/Dockerfile")) {
              Write-Error "Dockerfile not found in ./$SERVICE"
              exit 1
            }
          }
          
          Write-Host "All services validated successfully"

  build:
    needs: validate
    runs-on: [self-hosted, windows]
    strategy:
      matrix:
        service: [
          'appoitmentscheduler',
          'healthhelperauthsystem',
          'medicosservice',
          'schedulerconsumer',
          'userregisterconsumer'
        ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Get version
        id: get_version
        shell: pwsh
        run: |
          $version = git rev-parse --short HEAD
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT

      - name: Build and push
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $SERVICE = "${{ matrix.service }}"
          $VERSION = "${{ steps.get_version.outputs.VERSION }}"
          $IMAGE_NAME = "${{ env.REGISTRY }}/$SERVICE"
          
          Write-Host "Building $SERVICE..."
          
          docker build -t ${IMAGE_NAME}:${VERSION} ./$SERVICE
          if (-not $?) {
            Write-Error "Docker build failed for $SERVICE"
            exit 1
          }
          
          docker tag ${IMAGE_NAME}:${VERSION} ${IMAGE_NAME}:latest
          
          Write-Host "Pushing $SERVICE images..."
          docker push ${IMAGE_NAME}:${VERSION}
          docker push ${IMAGE_NAME}:latest

  deploy:
    needs: build
    runs-on: [self-hosted, windows]
    env:
      NAMESPACE: default
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Get version
        id: get_version
        shell: pwsh
        run: |
          $version = git rev-parse --short HEAD
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT

      - name: Verify Kubernetes Context
        shell: pwsh
        run: |
          try {
            Write-Host "Attempting to use minikube context..."
            kubectl config use-context minikube
            if (-not $?) {
              Write-Host "Minikube context failed, trying docker-desktop..."
              kubectl config use-context docker-desktop
            }
            
            kubectl get nodes
            if (-not $?) {
              throw "Failed to connect to Kubernetes cluster"
            }
            
            $context = kubectl config current-context
            Write-Host "Successfully connected to Kubernetes context: $context"
          }
          catch {
            Write-Error "Kubernetes context verification failed: $_"
            exit 1
          }

      - name: Apply Kubernetes Configurations
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $VERSION = "${{ steps.get_version.outputs.VERSION }}"
          $NAMESPACE = "${env:NAMESPACE}"
          
          # Função para aplicar configurações de um diretório
          function Apply-KubernetesConfigurations {
            param (
              [string]$Path
            )
            
            if (Test-Path $Path) {
              Write-Host "Applying configurations from $Path..."
              kubectl apply -f $Path
            }
          }
          
          # Aplicar configurações do RabbitMQ
          Apply-KubernetesConfigurations -Path "k8s/RabbitMQ"
          
          # Aplicar configurações base
          Apply-KubernetesConfigurations -Path "k8s/config"
          
          # Array com os serviços e seus diretórios
          $SERVICES = @(
            @{Name="HelHelperUser"; Dir="HelHelperUser"},
            @{Name="HelthHelperAuth"; Dir="HelthHelperAuth"},
            @{Name="HelthHelperConsumer"; Dir="HelthHelperConsumer"},
            @{Name="HelthHelperProducer"; Dir="HelthHelperProducer"}
          )
          
          foreach ($SERVICE in $SERVICES) {
            $serviceName = $SERVICE.Name
            $serviceDir = $SERVICE.Dir
            
            Write-Host "Deploying $serviceName..."
            
            try {
              # Verificar se o diretório k8s existe para o serviço
              $k8sPath = "k8s/$serviceDir"
              if (-not (Test-Path $k8sPath)) {
                Write-Warning "K8s directory not found for $serviceName at $k8sPath"
                continue
              }
              
              # Função para atualizar e aplicar arquivos YAML
              function Update-AndApplyYaml {
                param (
                  [string]$FilePath,
                  [string]$Version
                )
                
                $content = Get-Content $FilePath -Raw
                $updatedContent = $content -replace '(:latest|:v\d+\.\d+\.\d+|:[a-f0-9]+)', ":$Version"
                $updatedContent | Set-Content $FilePath
                
                Write-Host "Applying $(Split-Path $FilePath -Leaf)..."
                kubectl apply -f $FilePath
                
                if (-not $?) {
                  throw "Failed to apply $(Split-Path $FilePath -Leaf)"
                }
              }
              
              # Atualizar e aplicar todos os YAMLs no diretório do serviço
              Get-ChildItem $k8sPath -Filter *.yaml | ForEach-Object {
                Update-AndApplyYaml -FilePath $_.FullName -Version $VERSION
              }
              
              # Verificar deployment
              $deploymentName = "$serviceName-deployment"
              Write-Host "Waiting for $deploymentName rollout..."
              
              kubectl rollout status deployment/$deploymentName `
                -n $NAMESPACE `
                --timeout=300s
              
              if (-not $?) {
                throw "Deployment rollout failed"
              }
              
              Write-Host "$serviceName deployment successful"
            }
            catch {
              Write-Error "Failed to deploy $serviceName`: $_"
              
              # Logs para diagnóstico
              Write-Host "Deployment status:"
              kubectl get deployments -l app=$serviceName -n $NAMESPACE
              
              Write-Host "Pods status:"
              kubectl get pods -l app=$serviceName -n $NAMESPACE
              
              # Função para obter logs dos pods
              function Get-PodLogs {
                param (
                  [string]$ServiceName,
                  [string]$Namespace
                )
                
                $pods = kubectl get pods -l app=$ServiceName -n $Namespace -o name
                
                foreach ($podResource in $pods) {
                  # Remover o prefixo 'pod/' se existir
                  $podName = $podResource -replace '^pod/', ''
                  
                  Write-Host "Attempting to retrieve logs for pod: $podName"
                  
                  try {
                    $logOutput = kubectl logs $podName -n $Namespace --tail=50 2>&1
                    
                    if ($logOutput) {
                      Write-Host "Logs for $podName:"
                      $logOutput | ForEach-Object { Write-Host $_ }
                    }
                    else {
                      Write-Warning "No logs found for pod: $podName"
                    }
                  }
                  catch {
                    Write-Warning "Could not retrieve logs for pod: $podName. Error: $_"
                  }
                }
              }
              
              # Chamar função para obter logs
              Get-PodLogs -ServiceName $serviceName -Namespace $NAMESPACE
              
              exit 1
            }
          }

      - name: Verify Deployments
        if: success()
        shell: pwsh
        run: |
          $SERVICES = @(
            "HelHelperUser",
            "HelthHelperAuth",
            "HelthHelperConsumer",
            "HelthHelperProducer"
          )
          $NAMESPACE = "${env:NAMESPACE}"

          foreach ($SERVICE in $SERVICES) {
            Write-Host "Verifying $SERVICE..."
            
            # Verificar status do deployment
            $deployment = kubectl get deployment "$SERVICE-deployment" `
              -n $NAMESPACE `
              -o jsonpath='{.status.availableReplicas}'
            
            if ($deployment -lt 1) {
              Write-Error "Deployment $SERVICE does not have any available replicas"
              exit 1
            }
            
            Write-Host "$SERVICE verification completed successfully"
          }